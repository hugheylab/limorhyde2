---
title: "Quantifying rhythmicity with limorhyde2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{quantifying-rhythmicity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  rmarkdown.html_vignette.check_title = FALSE,
  message = FALSE,
  fig.align = 'center',
  fig.retina = 2
)
```

## Introduction

Here we show how to use limorhyde2 to quantify rhythmicity in data from one condition. The data are based on mouse liver samples from the [circadian gene expression atlas in mammals](https://doi.org/10.1073/pnas.1408886111) ([GSE54650](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE54650)).

## Load packages

```{r load_packages}
library('data.table')
library('ggplot2')
library('limorhyde2')
library('qs')

doParallel::registerDoParallel()
theme_set(theme_bw())
```

## Load the data

The expression data are in a matrix with one row per gene and one column per sample. The metadata are in a table with one row per sample.

```{r load_data}
y = qread(system.file('extdata', 'GSE54650_liver_data.qs', package = 'limorhyde2'))
y[1:10, 1:6]

metadata = qread(system.file('extdata', 'GSE54650_liver_metadata.qs', package = 'limorhyde2'))
metadata[, .(sample, time)]
```

## Fit linear models

The first step is to fit a series of linear models for each genomic feature, in this case each gene, using [limma](https://doi.org/doi:10.18129/B9.bioc.limma). `getModelFit()` takes several arguments besides the expression data and metadata, but here we just use the defaults. For example, the data are from one condition, so we leave `condColname` as `NULL`. Also, the expression data are from microarrays and already log-transformed, so we leave `method` as `'trend'`.

```{r model_fit}
fit = getModelFit(y, metadata)
```

## Get posterior fit

The next step is obtain posterior estimates of the model coefficients using [multivariate adaptive shrinkage](https://doi.org/10.1038/s41588-018-0268-8) ([mashr](https://stephenslab.github.io/mashr/index.html)), which learns patterns in the data and accounts for noise in the original fits. The defaults for `getPosteriorFit()` should work well in most cases.

```{r posterior_fit}
fit = getPosteriorFit(fit)
```

## Get rhythmic statistics

We can now use the posterior fits to compute rhythmic statistics, i.e. properties of the curve, for each gene. To save time in this vignette, the rhythmic statistics have been pre-calculated and stored as part of the package.

```{r rhythm_stats}
# rhyStats = getRhythmStats(fit)
rhyStats = qread(system.file('extdata', 'GSE54650_liver_rhy_stats.qs', package = 'limorhyde2'))
rhyStats
```

We can plot the distributions of the statistics in various ways, such as peak-to-trough amplitude vs. peak phase.

```{r plot_stat_point, fig.width = 6, fig.height = 4}
ggplot(rhyStats) +
  geom_point(aes(x = peak_phase, y = peak_trough_amp), alpha = 0.1, size = 0.5) +
  xlab('Peak phase (h)') +
  ylab('Peak-to-trough amplitude (norm.)') +
  scale_x_continuous(breaks = seq(0, 24, by = 4))
```

## Get observed and expected time-courses

We can use `getExpectedMeas()` to compute the expected measurements for one or more genes at one or more time-points, which correspond to the fitted curves. Here we plot the posterior fits and observed expression for three circadian clock genes. We use `mergeMeasMeta()` to combine expression data and metadata, and then convert from gene id to gene symbol.

```{r timecourse, fig.width = 3.5, fig.height = 6}
genes = data.table(id = c('18626', '12953', '12753'),
                   symbol = c('Per1', 'Cry2', 'Clock'))

measExp = getExpectedMeas(fit, times = seq(0, 24, by = 0.5), features = genes$id)
measExp = merge(measExp, genes, by.x = 'feature', by.y = 'id')

measObs = mergeMeasMeta(y, metadata[, .(sample, time)], features = genes$id)
measObs = merge(measObs, genes, by.x = 'feature', by.y = 'id')

ggplot() +
  facet_wrap(vars(symbol), scales = 'free_y', ncol = 1) +
  geom_line(data = measExp, aes(x = time, y = value)) +
  geom_point(data = measObs, aes(x = time %% 24, y = meas),
             color = 'blue', shape = 21) +
  labs(x = 'Circadian time (h)', y = 'Expression (norm.)') +
  scale_x_continuous(breaks = seq(0, 24, by = 4))
```