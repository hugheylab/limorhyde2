---
title: "Quantifying rhythmicity with LimoRhyde2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{quantifying-rhythmicity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  rmarkdown.html_vignette.check_title = FALSE
)
```

## Introduction

Here we show how to use LimoRhyde2 to quantify rhythmicity. The data are microarray samples of mouse liver tissues.

## Setup

We begin by preparing the R environment.

```{r setup}
library(limorhyde2)
library(data.table)
library(ggplot2)
library(qs)
foreach::registerDoSEQ()

theme_set(theme_bw())
```

## Load the data

Next, we load the sample data. The data consist of a gene-by-sample expression matrix and a data.table of sample metadata.

```{r}
mouseLiverData = qread(system.file('data', 'GSE54650_liver_data.qs', package = 'limorhyde2')) 
mouseLiverMetadata = qread(system.file('data', 'GSE54650_liver_metadata.qs', package = 'limorhyde2'))

#first 8 samples of expression data
head(mouseLiverData[, 1:6])
mouseLiverMetadata
```

## Fit linear models

The first step of the LimoRhyde2 workflow is to fit a series of linear models for each genomic feature.  For the example data, the name of the column containing the time at which a sample was taken is 'time'.

```{r, results = 'hide'}
fit = getModelFit(y = mouseLiverData, metadata = mouseLiverMetadata, timeColname = 'time')
```

## Get a posterior fit

Next, we obtain a model with moderated coefficient estimates using `getPosteriorFit`. We get the moderated coefficients by adjusting the raw fits based on shared patterns between features, conditions, and other covariates, as well as the amount of noise in the data.

```{r, results = 'hide'}
fit = getPosteriorFit(fit)
```

## Get rhythmic statistics

From the moderated model, we can get obtain estimates of the rhythmic statistics for a select set of genes using `getRhythmStats` (in our example, we use three clock genes: Per1, Cry2, and Clock). By default, `getRhythmStats` estimates from posterior means of coefficients, but it can also be used with the raw coefficients.

```{r}
clockGeneDt = data.table(id = as.character(c(18626, 12953, 12753)), gene_sym = c('Per1', 'Cry2', 'Clock'))

rhyStats = getRhythmStats(fit, features = clockGeneDt$id)
rhyStats
```

## Estimate fitted values 

We can also obtain fitted values based on the moderated estimates using `getExpectMeas`. These fitted values represent the expected expression level at each time point for each feature.

```{r, results = 'hide'}
fittedVals = getExpectedMeas(fit, times = seq(0, 24, by = 0.5), features = clockGeneDt$id)
fittedVals = merge(fittedVals, clockGeneDt, by.x = 'feature', by.y = 'id')
```

Below, we plot the fitted values from the moderated model. The points show the actual values of the data, while the lines show the fitted values at a given time.

```{r, fig.align='center', fig.width=8, fig.asp=0.5625}
#setting up data table with actual values for given time
actualVals = mouseLiverData[clockGeneDt$id, ]
actualVals = as.data.table(t(actualVals), keep.rownames = 'sample')
actualVals = merge(actualVals, mouseLiverMetadata, by = 'sample')
actualVals = melt(actualVals, measure.vars = clockGeneDt$id, 
                  variable.name = 'feature', value.name = 'value')
actualVals = merge(actualVals, clockGeneDt, by.x = 'feature', by.y = 'id')

ggplot() +
  geom_line(data = fittedVals, aes(x = time, y = value)) +
  geom_point(data = actualVals, aes(x = time %% 24, y = value), color = 'blue', shape = 1) +
  facet_wrap(vars(gene_sym), scales = 'free_y') +
  ylab('Expression (norm. RA)') +
  xlab('Circadian time (h)') +
  scale_x_continuous(breaks = seq(0, 24, by = 4))

```