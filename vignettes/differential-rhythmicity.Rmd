---
title: "Differential rhythmicity with LimoRhyde2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Differential rhythmicity with LimoRhyde2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  rmarkdown.html_vignette.check_title = FALSE 
)
```

## Introduction

Here we show how to use LimoRhyde2 to compare rhythmicity between two conditions. The data are microarray samples of mouse liver tissues with two conditions, wild-type and knockout.

## Setup

We begin by preparing the R environment.

```{r setup}
library(limorhyde2)
library(data.table)
library(ggplot2)
library(qs)
foreach::registerDoSEQ()

theme_set(theme_bw())
```

## Load the data

Next, we load the sample data. The data consist of a gene-by-sample expression matrix and a data.table of sample metadata.

```{r}
exprData = qread(system.file('data', 'GSE34018_data.qs', package = 'limorhyde2')) 
metadata = qread(system.file('data', 'GSE34018_metadata.qs', package = 'limorhyde2'))

#first 8 samples of expression data
head(exprData[, 1:6])
metadata
```

## Fit linear models

Next, we fit linear models to the data and obtain a posterior fit. 

```{r, results = 'hide'}
#fitting initial models
fit = getModelFit(y = exprData, metadata = metadata, condColname = 'cond')

#getting posterior fit
fit = getPosteriorFit(fit)
```

## Quantify rhythmicity and get differential rhythm stats

We use fit from the previous step to get a table of non-differential rhythmic statistics. See the [quantifying rhythmicity vignette](quantifying-rhythmicity.html) for more details. To save time in this vignette, we load the rhythmic statistics for the example dataset from the package data.

```{r}
#getting rhythm stats

# rhyStats = getRhythmStats(fit)
rhyStats = qread(system.file('data', 'GSE34018_rhystats.qs', package = 'limorhyde2'))
rhyStats
```

The last step is to pass the fit, rhythmic statistics, and the two conditions that you would like to compare (in our case, 'wild-type' and 'knockout') to `getDiffRhythmStats`. Since our table of rhythmic statistics is based on the posterior mean, the data.table output by `getDiffRhythmStats` will have one row per feature.

```{r}
diffRhyStats = getDiffRhythmStats(fit = fit, rhyStats = rhyStats, condLevels = levels(metadata$cond))
diffRhyStats
```

We can plot differential rhythmic statistics to identify potentially differentially-rhythmic genes.

```{r, fig.align='center', fig.width=8, fig.asp=0.5625}
ggplot(data = diffRhyStats) +
  geom_point(aes(x = diff_peak_phase, y = diff_peak_trough_amp), alpha = 0.3) +
  xlab('Difference in phase (h)') +
  ylab('Difference in peak-to-trough amplitude (norm.)') +
  scale_x_continuous(breaks = seq(-12, 12, by = 4))

ggplot(data = diffRhyStats) +
  geom_point(aes(x = diff_mean_value, y = diff_peak_trough_amp), alpha = 0.3) +
  xlab('Difference in mean expression (norm.)') +
  ylab('Difference in peak-to-trough amplitude (norm.)')
```

## Estimate fitted values

We can also investigate how fitted values vary between conditions using `getExpectMeas`. With a condition specified in the `fit`, the fitted values represent the expected expression level at each time point for each feature-condition pair.

```{r, results = 'hide'}
clockGeneDt = data.table(id = as.character(c(18626, 12953, 12753)), sym = c('Per1', 'Cry2', 'Clock'))

fittedVals = getExpectedMeas(fit, times = seq(0, 24, by = 0.5), features = clockGeneDt$id)
fittedVals = merge(fittedVals, clockGeneDt, by.x = 'feature', by.y = 'id')
```

Below, we plot the fitted values from the moderated model for the clock genes Per1, Cry2, and Clock. The points show the actual values of the data, while the lines show the fitted values at a given time.

```{r, fig.align='center', fig.width=8, fig.asp=0.35}
#setting up data table with actual values for given time
actualVals = exprData[clockGeneDt$id, ]
actualVals = as.data.table(t(actualVals), keep.rownames = 'sample')
actualVals = merge(actualVals, metadata, by = 'sample')
actualVals = melt(actualVals, measure.vars = clockGeneDt$id, 
                  variable.name = 'feature', value.name = 'value')
actualVals = merge(actualVals, clockGeneDt, by.x = 'feature', by.y = 'id')

ggplot() +
  facet_wrap(vars(sym), scales = 'free_y') +
  geom_line(data = fittedVals, aes(x = time, y = value, color = cond)) +
  geom_point(data = actualVals, aes(x = time %% 24, y = value, color = cond, shape = cond)) +
  labs(x = 'Circadian time (h)', y = 'Expression (norm.)', color = 'Condition', shape = 'Condition') +
  scale_x_continuous(breaks = seq(0, 24, by = 4)) +
  scale_color_brewer(palette = 'Dark2')

```